# Path Palnning Project Rubric Discussion

## Compilation

The code compiles with cmake and make. There were no modifications to the CMakeLists.txt.

## Valid Trajectories

As shown below the car is able to travel over 4.32 miles following all the constraints ( acceleration/jerk/speed limits, collision avoidance, and driving inside the lanes).

[![PID Controller](http://img.youtube.com/vi/QS_azTC0frc/0.jpg)](http://www.youtube.com/watch?v=QS_azTC0frc)

## Reflection

This implementation of the path planning project is influenced heavily by the Q&A session held by Aaron and David. The three major components of the path planner are trajectory generation, behavior planning and sensor fusion. Each one of them is discussed in detail below.

### Trajectory Generation

Trajectory generation involves calculation of a set of waypoints that can be followed by Ego in the simulator. These points have to follow a smooth curve and spaced such that the acceleration, jerk and speed do not exceed their respective limits. 

The method chosen to achieve these goals is the utilization of the spline library which can output points on a smooth curve generated by using multiple anchor points as inputs. Two previous positions of Ego and three points spaced 30 meters apart in the future were used as inputs. The previous positions are used to make sure there is continuity while transitioning between the current trajectory and the newly generated trajectory. Shown below are the code snippets which show estimation of previous positions (if unavailble) or addition of them to the previous points vector.

```C++
          // Not enough previous points, estimate position and angle
          if ( prev_size < 2 ) {
            double car_x_prev = car_x - cos(car_yaw);
            double car_y_prev = car_y - sin(car_yaw);

            pts_x.push_back(car_x_prev);
            pts_x.push_back(car_x);

            pts_y.push_back(car_y_prev);
            pts_y.push_back(car_y);
          } 
          else {

            ref_x = previous_path_x[prev_size - 1];
            ref_y = previous_path_y[prev_size - 1];

            double ref_x_prev = previous_path_x[prev_size - 2];
            double ref_y_prev = previous_path_y[prev_size - 2];
            ref_yaw = atan2(ref_y-ref_y_prev, ref_x-ref_x_prev);

            pts_x.push_back(ref_x_prev);
            pts_x.push_back(ref_x);

            pts_y.push_back(ref_y_prev);
            pts_y.push_back(ref_y);
          }

          // Calculate future anchor points
          vector<double> next_wp0 = getXY(car_s + 30, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);
          vector<double> next_wp1 = getXY(car_s + 60, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);
          vector<double> next_wp2 = getXY(car_s + 90, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);

```
Once the waypoints have been calculated, they are transformed into Ego's local cor-ordinate frame to simplify calculations. The transformed co-ordinates are fed to the spline function and points are extracted from the spline. To follow the acceleration/speed/jerk constraints, the spacing between the extracted points is varied based on required velocity as shown below.
```C++
            double N = target_dist/(0.02*ref_vel/2.24);
            double x_point = x_add_on + target_x/N;
            double y_point = s(x_point);
```



