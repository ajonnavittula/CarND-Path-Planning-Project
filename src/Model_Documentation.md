# Path Palnning Project Rubric Discussion

## Compilation

The code compiles with cmake and make. There were no modifications to the CMakeLists.txt.

## Valid Trajectories

As shown below the car is able to travel over 4.32 miles following all the constraints ( acceleration/jerk/speed limits, collision avoidance, and driving inside the lanes).

[![PID Controller](http://img.youtube.com/vi/QS_azTC0frc/0.jpg)](http://www.youtube.com/watch?v=QS_azTC0frc)

## Reflection

This implementation of the path planning project is influenced heavily by the Q&A session held by Aaron and David. The three major components of the path planner are trajectory generation, behavior planning and sensor fusion. Each one of them is discussed in detail below.

### Trajectory Generation

Trajectory generation involves calculation of a set of waypoints that can be followed by Ego in the simulator. These points have to follow a smooth curve and spaced such that the acceleration, jerk and speed do not exceed their respective limits. 

The method chosen to achieve these goals is the utilization of the spline library which can output points on a smooth curve generated by using multiple anchor points as inputs. Two previous positions of Ego and three points spaced 30 meters apart in the future were used as inputs. The previous positions are used to make sure there is continuity while transitioning between the current trajectory and the newly generated trajectory. Shown below is the code snippet which shows estimation of previous positions (if unavailable) or addition of them to the previous points vector and calculation of future waypoints.

```C++
          // Not enough previous points, estimate position and angle
          if ( prev_size < 2 ) {
            double car_x_prev = car_x - cos(car_yaw);
            double car_y_prev = car_y - sin(car_yaw);

            pts_x.push_back(car_x_prev);
            pts_x.push_back(car_x);

            pts_y.push_back(car_y_prev);
            pts_y.push_back(car_y);
          } 
          else {

            ref_x = previous_path_x[prev_size - 1];
            ref_y = previous_path_y[prev_size - 1];

            double ref_x_prev = previous_path_x[prev_size - 2];
            double ref_y_prev = previous_path_y[prev_size - 2];
            ref_yaw = atan2(ref_y-ref_y_prev, ref_x-ref_x_prev);

            pts_x.push_back(ref_x_prev);
            pts_x.push_back(ref_x);

            pts_y.push_back(ref_y_prev);
            pts_y.push_back(ref_y);
          }

          // Calculate future anchor points
          vector<double> next_wp0 = getXY(car_s + 30, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);
          vector<double> next_wp1 = getXY(car_s + 60, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);
          vector<double> next_wp2 = getXY(car_s + 90, 2 + 4*lane, map_waypoints_s, map_waypoints_x, map_waypoints_y);

```
Once the waypoints have been calculated, they are transformed into Ego's local co-ordinate frame to simplify calculations. The transformed co-ordinates are fed to the spline function and the required number of waypoints are extracted from the spline. To follow the acceleration/speed/jerk constraints, the spacing between the extracted points is varied based on required velocity as shown below.

```C++
            double N = target_dist/(0.02*ref_vel/2.24);
            double x_point = x_add_on + target_x/N;
            double y_point = s(x_point);
```
### Behavior Planning

Behavior planning involves using the output of sensor fusion to modify behavior of Ego. If there are no cars in the current lane, Ego accelerates to the speed limit and maintains it. If there is a car ahead but no car in the left or right lane, the behavior planner performs a Lane Change Left or Lane Change Right. If none of those options are possible, the planner slows down the velocity of Ego to match that of the car in front. The code snippet shown below shows Ego's behavior planner.

```C++
          if(car_ahead) {  
            if(lane > 0 && !car_left) { lane--; }
            else if (lane < 2 && !car_right) { lane++; }
            else if (ref_vel > car_ahead_vel) {
              if(fabs(ref_vel - car_ahead_vel) < 1.5 * MAX_ACC) { ref_vel = car_ahead_vel; }
              else { ref_vel -= 0.5 * MAX_ACC; }
            }
          }
          else {
            if (ref_vel < MAX_VEL) {ref_vel += MAX_ACC;} 
          }
```
### Sensor Fusion

Sensor fusion involves understanding the location of cars relative to Ego's position. The simulated outputs the lane location, velocity and distance of every car in Ego's vicinity. Based on these values the positions of each of the cars is estimated at a future state and based on where they located respective to Ego flags are set. If a car is ahead of Ego and within 30 meters, the `car_ahead` flag is set. If a car is either to the left or right of Ego and within 20 meters, the `car_left` or `car_right` flags are set. These flags are then used by the behavior planner to plan for lane changes or acceleration/braking. The code snippet below shows the calculations for flags.

```C++
            check_car_s += ((double)prev_size*0.02*check_speed);

            if (car_lane == lane && (check_car_s-car_s < 30) && check_car_s > car_s) {
              car_ahead = true;
              car_ahead_vel = check_speed;
            }
            else if (car_lane == (lane-1) && fabs(check_car_s-car_s) < 20) {
              car_left = true;
            }
            else if (car_lane == (lane+1) && fabs(check_car_s-car_s) < 20) {
              car_right = true;
            }
```
